Ce chapitre présente les technologies choisies pour le développement de l'application. Les technologies sont choisies afin de répondre au mieux aux besoins du projet. Des comparaisons entre différentes technologies ayant la même mission sont également effectuées afin de justifier les choix finaux.

\section{Language de programmation}

Il est possible de réaliser une application web comme BeePlace dans un nombre incroyable de languages différents. Cependant, concernant partie client de l'application, toutes les possibilités finiront par la même conclusion: le code sera exécuté dans le navigateur et donc dans un environnement JavaScript. En effet, JavaScript est le seul langage de programmation supporté par tous les navigateurs. Il n'est donc pas très pratique d'utiliser un autre langage que JavaScript pour le frontend de l'application. Pour avoir une cohérence entre le frontend et le backend, il est donc possible de coder l'entièreté de l'application en ECMAScript \cite{ecmascript}. ECMAScript est le standard sur lequel se base JavaScript ou encore Node.js \cite{nodejs}. Node.js quant à lui permet d'exécuter du JavaScript en dehors du navigateur, ce qui permet de l'utiliser pour le backend de l'application.

Utiliser JavaScript pour réaliser des applications web est donc une évidence. Cependant, JavaScript est un langage très permissif sans option de typage. Il est donc possible de faire de nombreuses erreurs qui ne seront détectées qu'au moment de l'exécution du code. Pour éviter ce problème, il est possible et de plus en plus courant d'utiliser TypeScript \cite{typescript}.

\subsection{TypeScript}

TypeScript est un langage de programmation créé par Microsoft qui est un sur-ensemble de JavaScript. Il est donc possible de compiler du code TypeScript en JavaScript, ce qui permet de l'utiliser dans n'importe quel environnement. Comme expliqué précédemment, JavaScript peut être utilisé pour développer l'application entière, notamment grâce à Node.js pour le backend. C'est bien entendu également le cas pour TypeScript.

TypeScript ajoute de nombreuses fonctionnalités à JavaScript, comme la possibilité de créer des types, des interfaces, des énumérations et bien d'autres. Les avantages à utiliser TypeScript sont donc nombreux:

\begin{itemize}
  \item Meilleure complétion dans les IDE, comme Visual Studio Code.
  \item Gestion automatique des imports dans les IDE.
  \item Evite de découvrir de nombreuses erreurs au runtime, car elles sont détectées au moment de la compilation.
  \item Refactoriser le code de façon plus sure en voyant directement les erreurs de types dans l'IDE.
  \item Lecture et compréhension du code plus facile, car les types sont explicitement définis.
\end{itemize}

De plus, les deux applications existantes de l'écosystème BeeScreens, Pimp My Wall et le Media Player, sont déjà écrites en TypeScript. Il est donc agréable d'avoir une certaine cohérence et uniformité dans les technologies utilisées.

\section{Frontend}

\subsection{Framework}

De nombreux frameworks JavaScript sont disponibles actuellement pour réaliser la partie frontend des applications web mais les trois principaux concurrents en terme de popularité sont React \cite{react}, Vue.js \cite{vue} et Angular \cite{angular}. D'innombrables autres possibilités voient le jour chaque année mais ces trois frameworks sont les plus populaires, les plus utilisés et les plus stables. Il est donc pertinent de se focaliser sur ces trois options pour le développement de BeePlace.

\subsubsection{Angular}

Angular est le plus ancien des trois et est développé et maintenu par Google. Le problème principal d'Angular est la taille du code généré. En effet, comme l'indique cette comparaison \cite{comparison-js-frameworks}, une application vierge en Angular pèse environ 560KB contre les 100KB des frameworks concurrents. Cette différence pèse d'autant plus lorsque l'application à réaliser n'est pas très conséquente, ce qui est le cas avec BeePlace. Cet écart de taille s'explique car Angular propose plus de fonctionnalités déjà intégrées que les autres frameworks. Angular est donc plus adapté pour des projets de plus grande envergure avec des équipes de développement plus importantes.

\subsubsection{React vs Vue}

Les deux options restantes sont donc React et Vue. Les différences entre les deux frameworks sont moindres. Les deux sont plus de légères librairies pour créer des applications réactives que des frameworks complets. Ils sont facilement extensibles afin d'ajouter les briques nécessaires au projet. Cependant, React a tout de mêmes quelques avantages sur Vue:

\begin{itemize}
  \item React reste plus populaire comme l'indique Google Trends \cite{google-trends-js-frameworks} et dispose donc de librairies pour répondre à tous les besoins qu'on pourrait rencontrer.
  \item De par sa popularité, React dispose d'une plus grande communauté et donc d'une plus grande quantité de ressources et d'aide en ligne.
  \item React est développé par un géant de l'industrie, Méta, ce qui lui assure une certaine pérennité.
  \item React est plus proche du JavaScript classique que Vue, ce qui permet de plus facilement l'appréhender pour un développeur connaissant déjà JavaScript.
  \item L'application Pimp My Wall existante est elle-même écrite en React, ce qui permet d'uniformiser les technologie. Le choix s'est donc tourné vers React.
\end{itemize}

Pour conclure, les deux frameworks étant très similaires et performants, la popularité de React a été le facteur principal dans le choix du framework afin de ne pas rencontrer de problèmes de ressources ou de documentation.

\subsubsection{React vs Next.js}

Comme expliqué précédemment, React n'est pas vraiment un framework mais plus une librairie. Le développeur doit donc chercher quelles librairies utiliser pour répondre à ses besoins et les imbriquer ensemble. Cette solution est plus flexible mais demande également plus de temps pour la mise en place du projet. Heureusement, il existe des solutions qui permettent de créer un projet React rapidement avec des choix concernant les bonnes pratiques déjà effectués. Le plus connu d'entre eux est Next.js \cite{nextjs}, un framework basé sur React. Les avantages principaux sont les suivants:

\begin{itemize}
  \item Système de routage intégré en fonction de la structure du projet.
  \item Rendre des pages côté serveur afin d'améliorer le référencement.
  \item Créer des fonctions côté serveur afin de ne pas exposer les clés d'API.
  \item Utilisation des variables d'environnement pour la configuration.
\end{itemize}

Les fonctionnalités évoquées sont toutes intéressantes mais dans le cas de ce projet, surtout la dernière est venue influencer le choix. En effet, Next.js permet de définir et d'utiliser des variables d'environnement qui sont injectées dans le code au lancement de l'application. Cela évite de devoir build toute l'application à nouveau à chaque fois qu'un changement de configuration est effectué comme il est nécessaire avec une application React classique. Le choix final s'est donc porté sur Next.js.

\subsection{Design de l'interface}

Il existe principalement deux catégories de librairie afin de styliser des applications web:

\begin{itemize}
  \item Les librairies avec des opinions très arrêtées et des composants prêts à être assemblés comme Bootstrap \cite{bootstrap} ou Material UI \cite{mui}.
  \item Les librairies facilitant l'écriture de CSS, comme Tailwind \cite{tailwindcss} ou UnoCSS \cite{unocss}.
\end{itemize}

La première catégorie est très adaptée pour créer une application rapidement mais la personnalisation devient plus compliquée par la suite. De plus, ces librairies sont souvent plus utiles dans le design d'applications classiques comme des panels d'administration qui nécessitent de nombreux composants. Dans le cas de BeePlace, l'interface utilisateur ne contient que très peu d'éléments et est donc plus adaptée à la deuxième catégorie de librairies, plus souple et personnalisable.

Le choix s'est tourné vers Tailwind qui est une librairie de plus en plus populaire se basant sur le principe des utility classes. La librairie met à disposition de nombreuses classes CSS bien pensées et étudiées afin de styliser avec cohérence les éléments HTML. Cela permet notamment de ne pas découpler l'HTML du CSS afin de limiter les effets de bords et de faciliter la lecture et la modification du code.

\section{Backend}

\subsection{Choix du langage}

Comme expliqué précédemment, le choix s'est tourné vers Node.js \cite{nodejs} afin d'utiliser un seul et même langage pour l'entièreté de l'application: TypeScript. Node.js permet d'utiliser les connaissances acquises en JavaScript côté client également pour le côté serveur. De plus, Node.js est un environnement très populaire, ce qui permet, en combinaison avec \Gls{npm}, de trouver des librairies pour presque toutes les problématiques possibles. De plus, les performances de Node.js sont très bonnes et il est possible de réaliser un scaling horizontal facilement en multipliant le nombre d'instances de l'application.

Pour finir, grâce à l'utilisation de TypeScript dans les deux applications, il est possible de partager du code, notamment les types entre les deux applications en créant un package. Cela permet d'éviter la duplication de code ainsi qu'être sûr de la cohérence des données.

\subsection{Framework}

Il existe de nombreux frameworks dans l'écosystème Node.js. La comparaison s'accentue sur les quatre frameworks les plus populaires et les plus maintenus, à savoir Express.js \cite{expressjs}, AdonisJS \cite{adonisjs}, Fastify \cite{fastify} et NestJS \cite{nestjs}.

% TODO: here

\begin{table}[h]
  \begin{center}
    \caption{Frameworks Backend Node.js}
    \begin{tabular}{c|l|r}
      Framework  & Nombre de stars & Type      \\ \hline
      Express.js & 60.7k           & Librairie \\
      AdonisJS   & 13.8k           & Framework \\
      Fastify    & 27.1k           & Librairie \\
      NestJS     & 56.2k           & Framework \\
    \end{tabular}
  \end{center}
\end{table}

Bien que le plus populaire, Express n'est pas à proprement parler un framework, mais plutôt une librairie. Il est donc nécessaire d'utiliser une multitude d'autres librairies pour gérer les routes, les middlewares, la validation et autre. Pour des applications web complexes, cela revient à essayer d'assembler un puzzle en essayant de faire fonctionner toutes les briques ensemble. C'est pourquoi il est souvent préférable d'utiliser un framework plus dogmatique et plus complet. Fastify, bien que plus rapide et plus moderne que son concurrent Express, se trouve dans la même catégorie des frameworks très minimalistes. Il reste donc AdonisJS et NestJS. Le premier promet d'inclure tout ce dont nous avons besoin afin d'être le plus productif possible. AdonisJS est souvent comparé au framework PHP Laravel sur cet aspect-là. Le soucis principal d'AdonisJS est sa popularité. Malheureusement, il s'agit du framework le moins connu de la liste et cela se fait ressentir dans l'écosystème. Il est plus compliqué de trouver des librairies pour des cas d'utilisation spécifiques. La dernière option est NestJS, qui est un framework de plus en plus populaire et très complet. Son architecture fait qu'il est très facilement extensible, notamment grâce à l'utilisation de modules et d'injection de dépendances. De plus, son implémentation des WebSockets est très complète et mise en avant contrairement à AdonisJS, ce qui est un point très important pour la réalisation de cette application qui contient majoritairement des communications temps réel. Le choix s'est donc porté sur NestJS.

\section{Communication temps réel}

Pour la communication en temps réel sur le web, nous avons principalement trois options. Les Server-Sent Events (SSE), les WebSockets et WebRTC.

\subsection{Server-Sent Events (SSE)}
Utiliser des Server-Sent Events (SSE) est une option possible et facile à mettre en place. Cependant, cette technologie est assez limitée et ne permet pas de faire de la communication bidirectionnelle. En effet, pour réaliser une communication du client au serveur il faudrait utiliser en addition des appels HTTP classiques. Il est donc préférable d'utiliser une autre technologie afin d'uniformiser les communications. De plus, SSE supporte uniquement les communications textuels, il n'est pas possible de transférer des données binaires, ce qui peut être limitant.

\subsection{WebRTC}
WebRTC permet de réaliser une communication bidirectionnelle entre deux clients sans passer par un serveur une fois la connexion établie. Ce concept, appelé pair-à pair ou peer to peer en anglais, est intéressant pour des projets dans lesquels les utilisateurs créent des salons privés entre amis afin de ne pas surcharger le serveur. Cependant dans le cas de BeePlace, il est nécessaire de passer par le serveur afin de pouvoir synchroniser l'état de la toile entre tous les utilisateurs. WebRTC n'est donc pas une option viable pour ce projet.

\subsection{WebSockets}
Pour finir, les WebSockets mettent à disposition tout ce qui est nécessaire pour réaliser une communication bidirectionnelle entre le client et le serveur. De plus, de nombreuses librairies sont disponibles dans l'écosystème JavaScript et TypeScript afin de rendre son utilisation le plus simple possible. La plus connue est Socket.io et les trois fonctionnalités les plus intéressantes qu'elle nous offre sont les suivantes:

\begin{itemize}
  \item Auto reconnexion: Socket.io gère automatiquement les reconnexions en cas de perte de connexion.
  \item Création de salons: Il est possible de créer des salons afin de limiter les communications à un groupe d'utilisateurs. Cette fonctionnalité peut être utile si nous souhaitons par exemple créer plusieurs toiles simultanément sur l'application.
  \item Intégration avec Redis: Il est possible d'utiliser Redis afin de stocker les salons et les utilisateurs connectés. Cela permet de faciliter le scaling horizontal en multipliant le nombre d'instances de l'application.
\end{itemize}

Le choix s'est donc porté sur les WebSockets et plus spécifiquement sur la librairie Socket.io pour la communication temps réel.

\section{Stockage}

\subsection{Bases de données}

L'idée de séparer le stockage de l'état de la toile entre plusieurs méthodes de stockage est venue assez naturellement. En effet, la toile actuelle doit être accessible très rapidement afin d'éviter un temps de chargement initial trop important à l'utilisateur lorsque celui-ci arrive sur la page. De plus, il peut être intéressant de stocker des métadonnées en plus des pixels actuels de la toile. Ces métadonnées représentent l'historique des pixels avec la date et l'utilisateur qui l'a placé afin de pouvoir retracer l'évolution de la toile ainsi qu'en faire diverses analyses. Pour conclure, il est nécessaire d'avoir deux types de stockage pour l'application: un très rapide pour l'état actuel de la toile et un second plus durable pour l'historique et diverses métadonnées.

\subsection{Stockage de l'état actuel de la toile}

Afin de garantir un accès rapide à l'état actuel de la toile, un cache doit être mis en place. Les deux options les plus fréquentes sont Redis ou simplement une structure de données dans la mémoire de l'application. La deuxième option est plus simple à mettre en place car elle ne demande aucun service tiers mais le cache devrait être recréé depuis le stockage durable à chaque redémarrage de l'application. Ce qui n'est pas le cas avec Redis qui est un service tiers.

D'autres options sont possibles comme utiliser un service de cache comme Memcached mais Redis reste le choix le plus populaire et le plus simple à mettre en place.

\subsection{Stockage durable}

Pour stocker l'historique de la pose des pixels, une base de données plus conventionnelle est nécessaire en supplément à Redis. Le choix s'est tourné sur PostgreSQL \cite{postgresql}, un système de gestion de base base de données SQL open source très populaire. Les besoins d'étant pas très complexes, de nombreuses autres possibilités auraient pu être utilisées comme SQLite ou MySQL. La familiarité avec PostgreSQL a été le facteur déterminant dans le choix de cette base de données.
