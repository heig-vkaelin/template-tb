Avant d'énumérer les technologies choisies, il faut noter que le temps pour réaliser le travail de Bachelor étant assez restreint, il est préférable de choisir une majorité de technologies déjà connues avec lesquelles le temps de prise en main est donc réduit. Cet argument a donc joué un rôle important dans le choix des technologies en combinaison avec les besoins du projet.

\section{TypeScript}

TypeScript \cite{typescript} est un langage de programmation créé par Microsoft qui est un sur-ensemble de JavaScript. Il est donc possible de compiler du code TypeScript en JavaScript, ce qui permet de l'utiliser dans n'importe quel environnement. TypeScript peut donc être utilisé dans l'application entière, que ce soit du côté de l'application frontend dans le navigateur ou du côté backend sur le serveur grâce à Node.js \cite{nodejs}, qui permet de faire tourner du JavaScript en dehors du navigateur.

TypeScript ajoute de nombreuses fonctionnalités à JavaScript, comme la possibilité de créer des types, des interfaces, des énumérations et bien d'autres. Les avantages à utiliser TypeScript sont donc nombreux:

\begin{itemize}
  \item Meilleure complétion dans les IDE, comme Visual Studio Code.
  \item Gestion automatique des imports dans les IDE.
  \item Evite de découvrir de nombreuses erreurs au runtime, car elles sont détectées au moment de la compilation.
  \item Refactoriser le code de façon plus sure en voyant directement les erreurs de types dans l'IDE.
  \item Lecture et compréhension du code plus facile, car les types sont explicitement définis.
\end{itemize}

De plus, les deux applications existantes, Pimp My Wall et le Media Player, sont déjà écrites en TypeScript. Il est donc agréable d'avoir une certaine cohérence et uniformité dans les technologies utilisées.

\section{Frontend}

L'environnement du développement web frontend est actuellement très morcelé. De nouveaux frameworks JavaScript voient le jour chaque année et il peut être compliqué de faire un choix pour la mise en place d'un projet vierge. L'argument de l'ancienneté du framework et sa stabilité sont donc d'autant plus importants.

\subsection{Framework}

Les trois frameworks JavaScript concurrents principaux actuellement sont React, Vue.js et Angular. Angular est le plus ancien des trois et est développé par Google. Cependant, il est également le plus lourd des trois et demande plus de temps pour être pris en main. Les différences entre Vue et React sont moindres. Les deux frameworks sont plus de légères librairies extensibles facilement afin d'ajouter les briques nécessaires au projet. Cependant, React reste plus populaire et a donc des librairies pour répondre à tous les besoins qu'on pourrait rencontrer. De plus, l'application Pimp My Wall existante est elle-même écrite en React, ce qui permet d'uniformiser les technologie. Le choix s'est donc tourné vers React.

Il aurait également été possible de mentionner les nouveaux arrivants comme Svelte ou Solid qui sont des frameworks encore plus légers que React et Vue. Cependant, ces frameworks sont encore très jeunes et ne disposent pas d'un écosystème aussi développé que React ou Vue.

Comme expliqué précédemment, React n'est pas vraiment un framework mais plus une librairie. Le développeur doit donc chercher quelles librairies utiliser pour répondre à ses besoins et les imbriquer ensemble. Cette solution est plus flexible mais demande également plus de temps pour la mise en place du projet. Heureusement, il existe des solutions qui permettent de créer un projet React rapidement avec des choix concernant les bonnes pratiques déjà effectués. Le plus connu d'entre eux est Next.js \cite{nextjs}, un framework basé sur React. Les avantages principaux sont les suivants:

\begin{itemize}
  \item Système de routage intégré en fonction de la structure du projet.
  \item Rendre des pages côté serveur afin d'améliorer le référencement.
  \item Créer des fonctions côté serveur afin de ne pas exposer les clés d'API.
  \item Utilisation des variables d'environnement pour la configuration.
\end{itemize}

Les fonctionnalités évoquées sont toutes intéressantes mais dans le cas de ce projet, surtout la dernière est venue influencer le choix. En effet, Next.js permet de définir et d'utiliser des variables d'environnement qui sont injectées dans le code au lancement de l'application. Cela évite de devoir build toute l'application à nouveau à chaque fois qu'un changement de configuration est effectué comme il est nécessaire avec une application React classique.

\subsection{Design}

Il existe principalement deux catégories de librairie afin de styliser des applications web:

\begin{itemize}
  \item Les librairies avec des opinions très arrêtées et des composants prêts à être assemblés comme Bootstrap ou Material UI.
  \item Les librairies facilitant l'écriture de CSS, comme Tailwind ou UnoCSS.
\end{itemize}

La première catégorie est très adaptée pour créer une application rapidement mais la personnalisation devient plus compliquée par la suite. De plus, ces librairies sont souvent plus utiles dans le design d'applications classiques comme des panels d'administration qui nécessitent de nombreux composants. Dans le cas de BeePlace, l'interface utilisateur ne contient que très peu d'éléments et est donc plus adaptée à la deuxième catégorie de librairies, plus souple et personnalisable.

Le choix s'est tourné vers Tailwind \cite{tailwindcss} qui est une librairie de plus en plus populaire se basant sur le principe des utility classes. La librairie met à disposition de nombreuses classes CSS bien pensées et étudiées afin de styliser avec cohérence les éléments HTML. Cela permet notamment de ne pas découpler l'HTML du CSS afin de limiter les effets de bords et de faciliter la lecture et la modification du code.

\section{Backend}

Comme expliqué précédemment, le choix s'est tourné vers Node.js \cite{nodejs} afin d'utiliser un seul et même langage pour l'entièreté de l'application: TypeScript. Node.js permet d'utiliser les connaissances acquises en JavaScript côté client également pour le côté serveur. De plus, Node.js est un environnement très populaire, ce qui permet, en combinaison avec \Gls{npm}, de trouver des librairies pour presque toutes les problématiques possibles. De plus, les performances de Node.js sont très bonnes et il est possible de réaliser un scaling horizontal facilement en multipliant le nombre d'instances de l'application.

Pour finir, grâce à l'utilisation de TypeScript dans les deux applications, il est possible de partager du code, notamment les types entre les deux applications en créant un package. Cela permet d'éviter la duplication de code ainsi qu'être sûr de la cohérence des données.

Il existe de nombreux frameworks dans l'écosystème Node.js, voici les principaux encore actuellement maintenus:

\begin{table}[h]
  \begin{center}
    \caption{Frameworks Backend Node.js}
    \begin{tabular}{c|l|r}
      Framework  & Nombre de stars & Type      \\ \hline
      Express.js & 60.7k           & Librairie \\
      AdonisJS   & 13.8k           & Framework \\
      Fastify    & 27.1k           & Librairie \\
      NestJS     & 56.2k           & Framework \\
    \end{tabular}
  \end{center}
\end{table}

Bien que le plus populaire, Express n'est pas à proprement parler un framework, mais plutôt une librairie. Il est donc nécessaire d'utiliser une multitude d'autres librairies pour gérer les routes, les middlewares, la validation et autre. Pour des applications web complexes, cela revient à essayer d'assembler un puzzle en essayant de faire fonctionner toutes les briques ensemble. C'est pourquoi il est souvent préférable d'utiliser un framework plus dogmatique et plus complet. Fastify, bien que plus rapide et plus moderne que son concurrent Express, se trouve dans la même catégorie des frameworks très minimalistes. Il reste donc AdonisJS et NestJS. Le premier promet d'inclure tout ce dont nous avons besoin afin d'être le plus productif possible. AdonisJS est souvent comparé au framework PHP Laravel sur cet aspect-là. Le soucis principal d'AdonisJS est sa popularité. Malheureusement, il s'agit du framework le moins connu de la liste et cela se fait ressentir dans l'écosystème. Il est plus compliqué de trouver des librairies pour des cas d'utilisation spécifiques. La dernière option est NestJS, qui est un framework de plus en plus populaire et très complet. Son architecture fait qu'il est très facilement extensible, notamment grâce à l'utilisation de modules et d'injection de dépendances. De plus, son implémentation des WebSockets est très complète et mise en avant contrairement à AdonisJS, ce qui est un point très important pour la réalisation de cette application qui contient majoritairement des communications temps réel. Le choix s'est donc porté sur NestJS.

\section{Communication temps réel}

Pour la communication en temps réel sur le web, nous avons principalement trois options. Les Server-Sent Events (SSE), les WebSockets et WebRTC.

\subsection{Server-Sent Events (SSE)}
Utiliser des Server-Sent Events (SSE) est une option possible et facile à mettre en place. Cependant, cette technologie est assez limitée et ne permet pas de faire de la communication bidirectionnelle. En effet, pour réaliser une communication du client au serveur il faudrait utiliser en addition des appels HTTP classiques. Il est donc préférable d'utiliser une autre technologie afin d'uniformiser les communications. De plus, SSE supporte uniquement les communications textuels, il n'est pas possible de transférer des données binaires, ce qui peut être limitant.

\subsection{WebRTC}
WebRTC permet de réaliser une communication bidirectionnelle entre deux clients sans passer par un serveur une fois la connexion établie. Ce concept, appelé pair-à pair ou peer to peer en anglais, est intéressant pour des projets dans lesquels les utilisateurs créent des salons privés entre amis afin de ne pas surcharger le serveur. Cependant dans le cas de BeePlace, il est nécessaire de passer par le serveur afin de pouvoir synchroniser l'état de la toile entre tous les utilisateurs. WebRTC n'est donc pas une option viable pour ce projet.

\subsection{WebSockets}
Pour finir, les WebSockets mettent à disposition tout ce qui est nécessaire pour réaliser une communication bidirectionnelle entre le client et le serveur. De plus, de nombreuses librairies sont disponibles dans l'écosystème JavaScript et TypeScript afin de rendre son utilisation le plus simple possible. La plus connue est Socket.io et les deux fonctionnalités les plus intéressantes qu'elle nous offre sont les suivantes:

\begin{itemize}
  \item Auto reconnexion: Socket.io gère automatiquement les reconnexions en cas de perte de connexion.
  \item Création de salons: Il est possible de créer des salons afin de limiter les communications à un groupe d'utilisateurs. Cette fonctionnalité peut être utile si nous souhaitons par exemple créer plusieurs toiles simultanément sur l'application.
  \item Intégration avec Redis: Il est possible d'utiliser Redis afin de stocker les salons et les utilisateurs connectés. Cela permet de faciliter le scaling horizontal en multipliant le nombre d'instances de l'application.
\end{itemize}

Le choix s'est donc porté sur les WebSockets et plus spécifiquement sur la librairie Socket.io pour la communication temps réel.

\section{Stockage}

\subsection{Bases de données}

L'idée de séparer le stockage de l'état de la toile entre plusieurs méthodes de stockage est venue assez naturellement. En effet, la toile actuelle doit être accessible très rapidement afin d'éviter un temps de chargement initial trop important à l'utilisateur lorsque celui-ci arrive sur la page. De plus, il peut être intéressant de stocker des métadonnées en plus des pixels actuels de la toile. Ces métadonnées représentent l'historique des pixels avec la date et l'utilisateur qui l'a placé afin de pouvoir retracer l'évolution de la toile ainsi qu'en faire diverses analyses. Pour conclure, il est nécessaire d'avoir deux types de stockage pour l'application: un très rapide pour l'état actuel de la toile et un second plus durable pour l'historique et diverses métadonnées.

\subsection{Stockage de l'état actuel de la toile}

Afin de garantir un accès rapide à l'état actuel de la toile, un cache doit être mis en place. Les deux options les plus fréquentes sont Redis ou simplement une structure de données dans la mémoire de l'application. La deuxième option est plus simple à mettre en place car elle ne demande aucun service tiers mais le cache devrait être recréé depuis le stockage durable à chaque redémarrage de l'application. Ce qui n'est pas le cas avec Redis qui est un service tiers.

D'autres options sont possibles comme utiliser un service de cache comme Memcached mais Redis reste le choix le plus populaire et le plus simple à mettre en place.

\subsection{Stockage durable}

Pour stocker l'historique de la pose des pixels, une base de données plus conventionnelle est nécessaire en supplément à Redis. Le choix s'est tourné sur PostgreSQL \cite{postgresql}, un système de gestion de base base de données SQL open source très populaire. Les besoins d'étant pas très complexes, de nombreuses autres possibilités auraient pu être utilisées comme SQLite ou MySQL. La familiarité avec PostgreSQL a été le facteur déterminant dans le choix de cette base de données.
